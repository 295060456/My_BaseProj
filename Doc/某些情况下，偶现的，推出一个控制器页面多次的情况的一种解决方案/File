
某些情况下，偶现的，推出一个控制器页面多次的情况的一种解决方案

【前置分析】
1、因为绝大部分的情况是botton点击跳转一个VC控制器，而目前市面上已有的大部分解决方案是对这个button进行操作，即：
点击以后x秒以内不允许处理该button的点击事件，让系统拥有充分的时间和空间去处理和响应请求；
2、问题：触发方式不仅仅有button，还有手势事件、cell的点击事件（UITableView、UICollectionView）...我们也需要预防苹果万一有一天会新推出一个方式来进行触发new对象事件，又需要我们进行适配。所以我的想法是不去关心中间过程，我们只关心最终结果，即：我们锚定是否此对象是否在内存独一无二的新增；
3、因为是new对象，所以不能使用对象方法、对象属性来记录是否创建了额外的对象。我们需要一个悬空的"上帝模式"来对次进行监控；
4、可用的“上帝模式”需要满足的点是：非数据本地化持久化的一个全局的变量；
5、我们仅需要在new对象成功以后对此“出生证明”进行记录。我选用的变量类型是数组，因为不需要键值对，也没有选用NSCache等使用频率较少的类，增加普适阅读性；
6、不能选用分类来进行，只能使用继承。理由是在分类里面不能写dealloc，因为那样写会崩溃。而我们需要在dealloc里面做-1的操作，在init方法里面做+1的操作；
7、通过遍历这个“出生证明”我们可以有且只有的创建这个对象；
8、目前iOS系统推VC控制器有且只有PUSH和PRESENT两种方式。如果我们只对navigationVC进行讨论，因为navigationVC是VC的一个具体子类，并且没有navigationVC我们也可以PRESENT，为了更广泛的涵盖面，所以也需要舍弃中间状态。也就是如果在某种偶现的情况下执行了new一个已经存在的对象，我们返回nil且终值执行推页面；
9、因为new的这个VC控制器页面是独立存在，不具备其他模块引用的问题，所以我们需要额外的一个全局的“上帝模式”的变量来记录它的存在；因为一个对象被其他不相干模块相互引用会徒增犯错误的风险，主要表现在相互作用下的强弱引用导致的死循环问题，第二就是代码量的上升带来的新接手的人员不熟悉私有Api造成的一系列维护成本问题；

